<!DOCTYPE html>
<html>
<head>	
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<meta charset="UTF-8">

	<script src='src/three.min.js'></script>
	<script src="src/stats.min.js"></script>
	<script src="src/ar.min.js"></script>

	<script src="src/inflate.min.js"></script>
	<script src="src/FBXLoader.js"></script>
	<!-- <script src="src/Detector.js"></script> -->

	<script>THREEx.ArToolkitContext.baseURL = 'ar/'</script>

	<title>ROBO</title>
	<style>
	html, body {
		width: 100%;
		height: 100%;
		overflow: hidden;
		position: fixed;
	}
	.overlay {
		position: sticky; 
		left: 0px; 
		top: 0px; 
		width: 100%; 
		height: 100%; 
		z-index: 100; 
		background-color: #ffffff88;
		overflow: hidden;
	}
</style>
</head>
<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>
	<script>

		//////////////////////////////////////////////////////////////////////////////////
		//		Init
		//////////////////////////////////////////////////////////////////////////////////

		// init renderer
		var renderer	= new THREE.WebGLRenderer({
			antialias	: true,
			alpha: true
		});
		renderer.setClearColor(new THREE.Color('lightgrey'), 0)
		// renderer.setPixelRatio( 1/2 );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.domElement.style.position = 'absolute'
		renderer.domElement.style.top = '0px'
		renderer.domElement.style.left = '0px'
		document.body.appendChild( renderer.domElement );

		// array of functions for the rendering loop
		var onRenderFcts= [];

		// init scene and camera
		var scene	= new THREE.Scene();
		
		//////////////////////////////////////////////////////////////////////////////////
		//		Initialize a basic camera
		//////////////////////////////////////////////////////////////////////////////////

		// Create a camera
		var camera = new THREE.Camera();
		scene.add(camera);

		////////////////////////////////////////////////////////////////////////////////
		//          handle arToolkitSource
		////////////////////////////////////////////////////////////////////////////////

		var arToolkitSource = new THREEx.ArToolkitSource({
			sourceType : 'webcam',
		})

		arToolkitSource.init(function onReady(){
			onResize()
		})
		
		// handle resize
		window.addEventListener('resize', function(){
			onResize()
		})
		function onResize(){
			arToolkitSource.onResizeElement()	
			arToolkitSource.copyElementSizeTo(renderer.domElement)	
			if( arToolkitContext.arController !== null ){
				arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas)	
			}	
		}
		////////////////////////////////////////////////////////////////////////////////
		//          initialize arToolkitContext
		////////////////////////////////////////////////////////////////////////////////
		

		// create atToolkitContext
		var arToolkitContext = new THREEx.ArToolkitContext({
			cameraParametersUrl: THREEx.ArToolkitContext.baseURL + 'camera_para.dat',
			detectionMode: 'mono',
			maxDetectionRate: 30,
			canvasWidth: 80*3,
			canvasHeight: 60*3,
		})
		// initialize it
		arToolkitContext.init(function onCompleted(){
			// copy projection matrix to camera
			camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
		})

		// update artoolkit on every frame
		onRenderFcts.push(function(){
			if( arToolkitSource.ready === false )	return

				arToolkitContext.update( arToolkitSource.domElement )
		})
		
		
		////////////////////////////////////////////////////////////////////////////////
		//          Create a ArMarkerControls
		////////////////////////////////////////////////////////////////////////////////
		
		var markerRoot = new THREE.Group
		scene.add(markerRoot)
		var artoolkitMarker = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
			type : 'pattern',
			//patternUrl : THREEx.ArToolkitContext.baseURL + 'patt.hiro'
			patternUrl : THREEx.ArToolkitContext.baseURL + 'marker-robo-2.patt'
			//patternUrl : THREEx.ArToolkitContext.baseURL + 'patt.kanji'
		})
		console.log("path = " +  THREEx.ArToolkitContext.baseURL);

		// build a smoothedControls
		var smoothedRoot = new THREE.Group()
		scene.add(smoothedRoot)
		var smoothedControls = new THREEx.ArSmoothedControls(smoothedRoot, {
			lerpPosition: 0.4,
			lerpQuaternion: 0.3,
			lerpScale: 1,
		})
		onRenderFcts.push(function(delta){
			smoothedControls.update(markerRoot)
		})
		//////////////////////////////////////////////////////////////////////////////////
		//		add an object in the scene
		//////////////////////////////////////////////////////////////////////////////////

		var light = new THREE.AmbientLight( 0x222222, 4.3 ); // soft white light
		scene.add( light );

		var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
		directionalLight.castShadow = true;
		directionalLight.position = (5,10,7.5)
		scene.add( directionalLight );

		light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
		light.position.set( 0, 200, 0 );
		scene.add( light );

		var arWorldRoot = smoothedRoot

		// model
		var manager = new THREE.LoadingManager();
		manager.onStart = function ( url, itemsLoaded, itemsTotal ) {
			//console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
		};
		manager.onLoad = function ( ) {
			console.log( 'Loading complete!');
		};
		manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
			//console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
		};
		manager.onError = function ( url ) {
			console.log( 'There was an error loading ' + url );
		};

		var loader = new THREE.FBXLoader(manager);
		//loader.load( 'models/fbx/samoletche binary.fbx', function ( object ) {
			loader.load( 'models/samoletche13.fbx', function ( object ) {
				console.log("in loader.load")
				console.log(object)
				
			/*
			object.mixer = new THREE.AnimationMixer( object );
			mixers.push( object.mixer );

			var action = object.mixer.clipAction( object.animations[ 0 ] );
			action.play();
			*/
			object.traverse( function ( child ) {

				if ( child.isMesh ) {

					child.castShadow = true;
					child.receiveShadow = true;
					console.log(child.name);
					//console.log(child);

					if (child.name == "Perki")
					{
						onRenderFcts.push(function(){
							child.rotation.z += 0.2
						});						
					} else if (child.name == "Body") {
						onRenderFcts.push(function(){
							if (isTouching) {
								//child.position.x += startX * .1;
								if (speedX > 0) {
									child.position.x -= 0.01;
								} else {
									child.position.x += 0.01;
								}
							}
						});	
					}
				}

			} );						

			arWorldRoot.add( object );
		} );

		//////////////////////////////////////////////////////////////////////////////////
		//		render the whole thing on the page
		//////////////////////////////////////////////////////////////////////////////////
		var stats = new Stats();
		document.body.appendChild( stats.dom );
		// render the scene
		onRenderFcts.push(function(){
			renderer.render( scene, camera );
			stats.update();
		})

		// run the rendering loop
		var lastTimeMsec= null
		requestAnimationFrame(function animate(nowMsec){
			// keep looping
			requestAnimationFrame( animate );
			// measure time
			lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
			var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
			lastTimeMsec	= nowMsec
			// call each update function
			onRenderFcts.forEach(function(onRenderFct){
				onRenderFct(deltaMsec/1000, nowMsec/1000)
			})
		})



		// HELPER FUNCTIONS
		// Rotate an object around an arbitrary axis in object space
		var rotObjectMatrix;
		function rotateAroundObjectAxis(object, axis, radians) {
			rotObjectMatrix = new THREE.Matrix4();
			rotObjectMatrix.makeRotationAxis(axis.normalize(), radians);

		    // old code for Three.JS pre r54:
		    // object.matrix.multiplySelf(rotObjectMatrix);      // post-multiply
		    // new code for Three.JS r55+:
		    object.matrix.multiply(rotObjectMatrix);

		    // old code for Three.js pre r49:
		    // object.rotation.getRotationFromMatrix(object.matrix, object.scale);
		    // old code for Three.js r50-r58:
		    // object.rotation.setEulerFromRotationMatrix(object.matrix);
		    // new code for Three.js r59+:
		    object.rotation.setFromRotationMatrix(object.matrix);
		}

		var rotWorldMatrix;
		// Rotate an object around an arbitrary axis in world space       
		function rotateAroundWorldAxis(object, axis, radians) {
			rotWorldMatrix = new THREE.Matrix4();
			rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);

		    // old code for Three.JS pre r54:
		    //  rotWorldMatrix.multiply(object.matrix);
		    // new code for Three.JS r55+:
		    rotWorldMatrix.multiply(object.matrix);                // pre-multiply

		    object.matrix = rotWorldMatrix;

		    // old code for Three.js pre r49:
		    // object.rotation.getRotationFromMatrix(object.matrix, object.scale);
		    // old code for Three.js pre r59:
		    // object.rotation.setEulerFromRotationMatrix(object.matrix);
		    // code for r59+:
		    object.rotation.setFromRotationMatrix(object.matrix);
		}

		var speedX;
		var isTouching = false;
		var startX = 0;		

		window.addEventListener('touchstart', function(e) {
			isTouching = true;
		    startX = e.touches[0].clientX;
		});

		window.addEventListener('touchmove', function(e) {
		    var te = e.changedTouches[0].clientX;		    
	        speedX = startX - te;
	        console.log(speedX);
		    startX = te;
		});

		window.addEventListener('touchend', function() {
			isTouching = false;
			directionIsLeft *= -1;
		});


</script>
</body>
</html>